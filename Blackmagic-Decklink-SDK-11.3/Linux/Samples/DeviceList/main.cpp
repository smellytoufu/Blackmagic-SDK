/* -LICENSE-START-
** Copyright (c) 2018 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/
#include "DeckLinkAPI.h"
#include <stdio.h>
#include <list>
#include <map>
#include <string>
#include "platform.h"

// List of known pixel formats and their matching display names
static const std::list<std::pair<BMDPixelFormat, std::string>> gPixelFormats =
{
	{ bmdFormat8BitYUV,     "8-bit YUV" },
	{ bmdFormat10BitYUV,    "10-bit YUV" },
	{ bmdFormat8BitARGB,    "8-bit ARGB" },
	{ bmdFormat8BitBGRA,    "8-bit BGRA" },
	{ bmdFormat10BitRGB,    "10-bit RGB" },
	{ bmdFormat12BitRGB,    "12-bit RGB" },
	{ bmdFormat12BitRGBLE,  "12-bit RGBLE" },
	{ bmdFormat10BitRGBXLE, "10-bit RGBXLE" },
	{ bmdFormat10BitRGBX,   "10-bit RGBX" },
};

static const std::list<std::pair<BMDVideoConnection, std::string>> gConnections =
{
	{ bmdVideoConnectionSDI,        "SDI" },
	{ bmdVideoConnectionHDMI,       "HDMI" },
	{ bmdVideoConnectionOpticalSDI, "Optical SDI" },
	{ bmdVideoConnectionComponent,  "Component" },
	{ bmdVideoConnectionComposite,  "Composite" },
	{ bmdVideoConnectionSVideo,     "S-Video" },
};

static const std::list<std::pair<BMDSupportedVideoModeFlags, std::string>> gSDILinks =
{
	{ bmdSupportedVideoModeSDISingleLink,	"Single-Link" },
	{ bmdSupportedVideoModeSDIDualLink,		"Dual-Link" },
	{ bmdSupportedVideoModeSDIQuadLink,		"Quad-Link" },
};

static const std::map<uint32_t, const char*> gDuplexModes =
{
	{ bmdDuplexInactive, 	"Inactive" },
	{ bmdDuplexFull, 		"Full" },
	{ bmdDuplexSimplex, 	"Simplex" },
	{ bmdDuplexHalf, 		"Half" },
};

void	print_attributes (IDeckLink* deckLink, bool showConnectorAttributes);
void	mode_name(IDeckLinkDisplayMode *displayMode, std::string& modeName);
void	print_output_mode(IDeckLinkOutput* deckLinkOutput, BMDVideoConnection connection, BMDSupportedVideoModeFlags flags, IDeckLinkDisplayMode *displayMode);
void	print_output_modes_for_setup (IDeckLinkOutput* deckLinkOutput, BMDVideoConnection connection, BMDSupportedVideoModeFlags flags);
void	print_output_modes (IDeckLink* deckLink);
void	print_input_mode(IDeckLinkInput* deckLinkInput, BMDVideoConnection connection, BMDSupportedVideoModeFlags flags, IDeckLinkDisplayMode* displayMode, const char* nameSuffix);
void	print_input_modes_for_setup (IDeckLinkInput* deckLinkInput, BMDVideoConnection connection, BMDSupportedVideoModeFlags flags, const char* nameSuffix);
void	print_input_modes (IDeckLink* deckLink);


int		main (int argc, char** argv)
{
	IDeckLinkIterator*			deckLinkIterator;
	IDeckLinkAPIInformation*	deckLinkAPIInformation;
	IDeckLink*					deckLink;
	IDeckLinkProfileAttributes*	deckLinkAttributes = NULL;
	int							numDevices = 0;
	HRESULT						result;
	
	// Create an IDeckLinkIterator object to enumerate all DeckLink cards in the system
	result = GetDeckLinkIterator(&deckLinkIterator);
	if (result != S_OK)
	{
		fprintf(stderr, "A DeckLink iterator could not be created.  The DeckLink drivers may not be installed.\n");
		return 1;
	}
	
	// We can get the version of the API like this:
	result = deckLinkIterator->QueryInterface(IID_IDeckLinkAPIInformation, (void**)&deckLinkAPIInformation);
	if (result == S_OK)
	{
		int64_t			deckLinkVersion;
		int				dlVerMajor, dlVerMinor, dlVerPoint;
		
		// We can also use the BMDDeckLinkAPIVersion flag with GetString
		deckLinkAPIInformation->GetInt(BMDDeckLinkAPIVersion, &deckLinkVersion);
		
		dlVerMajor = (deckLinkVersion & 0xFF000000) >> 24;
		dlVerMinor = (deckLinkVersion & 0x00FF0000) >> 16;
		dlVerPoint = (deckLinkVersion & 0x0000FF00) >> 8;
		
		printf("DeckLinkAPI version: %d.%d.%d\n", dlVerMajor, dlVerMinor, dlVerPoint);
		
		deckLinkAPIInformation->Release();
	}
	
	// Enumerate all cards in this system
	while (deckLinkIterator->Next(&deckLink) == S_OK)
	{
		dlstring_t deviceNameString;
		
		// Increment the total number of DeckLink cards found
		numDevices++;
		if (numDevices > 1)
			printf("\n\n");
		
		// *** Print the model name of the DeckLink card
		result = deckLink->GetModelName(&deviceNameString);
		if (result == S_OK)
		{
			std::string deviceName = DlToStdString(deviceNameString);
			printf("=============== %s ===============\n\n", deviceName.c_str());
			DeleteString(deviceNameString);
		}
		
		// Products with multiple subdevices might not be usable if a subdevice is inactive for the current profile
		bool showIOinfo = true;
		result = deckLink->QueryInterface(IID_IDeckLinkProfileAttributes, (void**)&deckLinkAttributes);
		if (result != S_OK)
		{
			fprintf(stderr, "Could not obtain the IDeckLinkProfileAttributes interface - result = %08x\n", result);
			continue;
		}

		int64_t duplexMode;
		if (deckLinkAttributes->GetInt(BMDDeckLinkDuplex, &duplexMode) == S_OK && duplexMode == bmdDuplexInactive)
		{
			printf("Sub-device has no active connectors for current profile\n\n");
			showIOinfo = false;
		}

		deckLinkAttributes->Release();
		
		print_attributes(deckLink, showIOinfo);
		
		if (showIOinfo)
		{
		
			// ** List the video output display modes supported by the card
			print_output_modes(deckLink);
			
			// ** List the video input display modes supported by the card
			print_input_modes(deckLink);
			
		}
		
		// Release the IDeckLink instance when we've finished with it to prevent leaks
		deckLink->Release();
	}
	
	deckLinkIterator->Release();	

	// If no DeckLink cards were found in the system, inform the user
	if (numDevices == 0)
		printf("No Blackmagic Design devices were found.\n");
	printf("\n");
	
	return 0;
}

void	print_attributes (IDeckLink* deckLink, bool showConnectorAttributes)
{
	IDeckLinkProfileAttributes*			deckLinkAttributes = NULL;
	dlbool_t							supported;
	int64_t								value;
	HRESULT								result;
	
	// Query the DeckLink for its attributes interface
	result = deckLink->QueryInterface(IID_IDeckLinkProfileAttributes, (void**)&deckLinkAttributes);
	if (result != S_OK)
	{
		fprintf(stderr, "Could not obtain the IDeckLinkProfileAttributes interface - result = %08x\n", result);
		goto bail;
	}
	
	// List attributes and their value
	printf("Attribute list:\n");
	
	result = deckLinkAttributes->GetInt(BMDDeckLinkDeviceInterface, &value);
	if (result == S_OK)
	{
		switch(value)
		{
			case bmdDeviceInterfacePCI:
				printf(" %-40s %s\n", "Device Interface:",  "PCI");
				break;
			case bmdDeviceInterfaceUSB:
				printf(" %-40s %s\n", "Device Interface:",  "USB");
				break;
			case bmdDeviceInterfaceThunderbolt:
				printf(" %-40s %s\n", "Device Interface",  "Thunderbolt");
				break;
		}
	}
	else
	{
		fprintf(stderr, "Could not query the device interface attribute- result = %08x\n", result);
	}

	result = deckLinkAttributes->GetInt(BMDDeckLinkPersistentID, &value);
	if (result == S_OK)
	{
		printf(" %-40s %llx\n", "Device Persistent ID:",  value);
	}
	else
	{
		printf(" %-40s %s\n", "Device Persistent ID:",  "Not Supported on this device");
	}

	result = deckLinkAttributes->GetInt(BMDDeckLinkTopologicalID, &value);
	if (result == S_OK)
	{
		printf(" %-40s %llx\n", "Device Topological ID:",  value);
	}
	else
	{
		printf(" %-40s %s\n", "Device Topological ID:",  "Not Supported on this device");
	}

	result = deckLinkAttributes->GetInt(BMDDeckLinkNumberOfSubDevices, &value);
	if (result == S_OK)
	{
		printf(" %-40s %lld\n", "Number of sub-devices:",  value);
		if (value != 0)
		{
			result = deckLinkAttributes->GetInt(BMDDeckLinkSubDeviceIndex, &value);
			if (result == S_OK)
			{
				printf(" %-40s %lld\n", "Sub-device index:",  value);
			}
			else
			{
				fprintf(stderr, "Could not query the sub-device index attribute- result = %08x\n", result);
			}
		}
	}
	else
	{
		fprintf(stderr, "Could not query the number of sub-device attribute- result = %08x\n", result);
	}
	
	if (! showConnectorAttributes)
		goto bail;
	
	result = deckLinkAttributes->GetFlag(BMDDeckLinkHasSerialPort, &supported);
	if (result == S_OK)
	{
		printf(" %-40s %s\n", "Serial port present:",  supported ? "Yes" : "No");
		if (supported)
		{
			dlstring_t name;
			result = deckLinkAttributes->GetString(BMDDeckLinkSerialPortDeviceName, &name);
			if (result == S_OK)
			{
				std::string	portName = DlToStdString(name);
				printf(" %-40s %s\n", "Serial port name:",  portName.c_str());
				
				DeleteString(name);
			}
			else
			{
				fprintf(stderr, "Could not query the serial port name attribute- result = %08x\n", result);
			}
		}
		
	}
	else
	{
		fprintf(stderr, "Could not query the serial port presence attribute- result = %08x\n", result);
	}
	
	result = deckLinkAttributes->GetInt(BMDDeckLinkMaximumAudioChannels, &value);
	if (result == S_OK)
	{
		printf(" %-40s %lld\n", "Number of audio channels:",  value);
	}
	else
	{
		fprintf(stderr, "Could not query the number of supported audio channels attribute- result = %08x\n", result);
	}

	result = deckLinkAttributes->GetFlag(BMDDeckLinkSupportsInputFormatDetection, &supported);
	if (result == S_OK)
	{
		printf(" %-40s %s\n", "Input mode detection supported ?", supported ? "Yes" : "No");
	}
	else
	{
		fprintf(stderr, "Could not query the input mode detection attribute- result = %08x\n", result);
	}

	result = deckLinkAttributes->GetInt(BMDDeckLinkDuplex, &value);
	if (result == S_OK)
	{
		printf(" %-40s %s\n", "Duplex Mode:", gDuplexModes.at(value));
	}
	else
	{
		fprintf(stderr, "Could not query the of sub-device duplex attribute- result = %08x\n", result);
	}
	
	result = deckLinkAttributes->GetFlag(BMDDeckLinkSupportsInternalKeying, &supported);
	if (result == S_OK)
	{
		printf(" %-40s %s\n", "Internal keying supported ?", supported ? "Yes" : "No");
	}
	else
	{
		fprintf(stderr, "Could not query the internal keying attribute- result = %08x\n", result);
	}
	
	result = deckLinkAttributes->GetFlag(BMDDeckLinkSupportsExternalKeying, &supported);
	if (result == S_OK)
	{
		printf(" %-40s %s\n", "External keying supported ?", supported ? "Yes" : "No");
	}
	else
	{
		fprintf(stderr, "Could not query the external keying attribute- result = %08x\n", result);
	}
	
bail:
	printf("\n");
	if(deckLinkAttributes != NULL)
		deckLinkAttributes->Release();
}

void mode_name(IDeckLinkDisplayMode *displayMode, std::string& modeName)
{
	HRESULT					result;
	dlstring_t				displayModeString;

	result = displayMode->GetName(&displayModeString);
	if (result != S_OK)
	{
		modeName.clear();
		return;
	}

	modeName = DlToStdString(displayModeString);
	DeleteString(displayModeString);
}

void print_output_mode(IDeckLinkOutput* deckLinkOutput, BMDVideoConnection connection, BMDSupportedVideoModeFlags flags, IDeckLinkDisplayMode *displayMode)
{
	std::string				modeName;
	int						modeWidth;
	int						modeHeight;
	BMDTimeValue			frameRateDuration;
	BMDTimeScale			frameRateScale;
	bool					printedMode = false;
	int						unsupportedCount = 0;
	BMDDisplayMode			requestedMode = displayMode->GetDisplayMode();
	BMDDisplayMode			actualMode = requestedMode;

	// Print the supported pixel formats for this display mode
	for (auto pixelFormat: gPixelFormats)
	{
		dlbool_t supported;
		if (deckLinkOutput->DoesSupportVideoMode(connection, requestedMode, pixelFormat.first, flags, &actualMode, &supported) == S_OK && supported)
		{
			if (! printedMode)
			{
				// Mode properties
				mode_name(displayMode, modeName);
				displayMode->GetFrameRate(&frameRateDuration, &frameRateScale);
				bool requested3D = (flags & bmdSupportedVideoModeDualStream3D) != 0;
				bool converted = actualMode != requestedMode;
				modeWidth = displayMode->GetWidth();
				modeHeight = displayMode->GetHeight();
				
				std::string tag;
				if (requested3D)
					tag = "3D";
				if (converted)
					tag += "*";
				
				printf(" %-20s %-12s \t %4d x %4d \t %7g FPS\t", modeName.c_str(), tag.c_str(), modeWidth, modeHeight, (double)frameRateScale / (double)frameRateDuration);
				
				// Show pixel formats already found to be unsupported
				while (unsupportedCount--)
				{
					printf("%-15s", "------");
				}
				
				printedMode = true;
			}
			
			printf("%-15s", pixelFormat.second.c_str());
		}
		else
		{
			if (printedMode)
				printf("%-15s", "------");
			else
				unsupportedCount++;
		}
	}
	
	if (printedMode)
	{
		
		if (actualMode != requestedMode)
		{
			// Append converted-to mode
			if (deckLinkOutput->GetDisplayMode(actualMode, &displayMode) == S_OK)
			{
				mode_name(displayMode, modeName);
				displayMode->Release();
				printf("* Converted to %s", modeName.c_str());
			}
		}
		
		printf("\n");
	}
}

void	print_output_modes_for_setup (IDeckLinkOutput* deckLinkOutput, BMDVideoConnection connection, BMDSupportedVideoModeFlags flags)
{
	IDeckLinkDisplayModeIterator*	displayModeIterator = NULL;
	IDeckLinkDisplayMode*			displayMode = NULL;
	HRESULT							result;
	
	// Obtain an IDeckLinkDisplayModeIterator to enumerate the display modes supported on output
	result = deckLinkOutput->GetDisplayModeIterator(&displayModeIterator);
	if (result != S_OK)
	{
		fprintf(stderr, "Could not obtain the video output display mode iterator - result = %08x\n", result);
		return;
	}
	
	while (displayModeIterator->Next(&displayMode) == S_OK)
	{
		print_output_mode(deckLinkOutput, connection, flags, displayMode);
		displayMode->Release();
	}
	
	displayModeIterator->Release();
}

void	print_output_modes (IDeckLink* deckLink)
{
	IDeckLinkOutput*					deckLinkOutput = NULL;
	IDeckLinkProfileAttributes*			deckLinkAttributes = NULL;
	HRESULT								result;
	int64_t								ports;
	dlbool_t							keyingSupported;

	// Query the DeckLink for its output interface
	result = deckLink->QueryInterface(IID_IDeckLinkOutput, (void**)&deckLinkOutput);
	if (result != S_OK)
	{
		fprintf(stderr, "Could not obtain the IDeckLinkOutput interface - result = %08x\n", result);
		goto bail;
	}
	
	result = deckLink->QueryInterface(IID_IDeckLinkProfileAttributes, (void**)&deckLinkAttributes);
	if (result != S_OK)
	{
		fprintf(stderr, "Could not obtain the IDeckLinkAttributes interface - result = %08x\n", result);
		goto bail;
	}

	result = deckLinkAttributes->GetFlag(BMDDeckLinkSupportsInternalKeying, &keyingSupported);

	if (result != S_OK || !keyingSupported)
		result = deckLinkAttributes->GetFlag(BMDDeckLinkSupportsExternalKeying, &keyingSupported);

	// List all supported output display modes
	printf("Supported video output display modes:\n\n");

	result = deckLinkAttributes->GetInt(BMDDeckLinkVideoOutputConnections, &ports);

	if (result != S_OK)
		goto bail;

	for (auto connection: gConnections)
	{
		if (ports & connection.first)
		{
			if (connection.first == bmdVideoConnectionSDI || connection.first == bmdVideoConnectionOpticalSDI)
			{
				for (std::list<std::pair<BMDSupportedVideoModeFlags, std::string>>::const_reverse_iterator links = gSDILinks.rbegin(); links != gSDILinks.rend(); links++)
				{
					dlbool_t multilinkSupported = false;
					if (links->first & bmdSupportedVideoModeSDIDualLink)
					{
						if (FAILED(deckLinkAttributes->GetFlag(BMDDeckLinkSupportsDualLinkSDI, &multilinkSupported)) || ! multilinkSupported)
							continue;
					}
					else if (links->first & bmdSupportedVideoModeSDIQuadLink)
					{
						if (FAILED(deckLinkAttributes->GetFlag(BMDDeckLinkSupportsQuadLinkSDI, &multilinkSupported)) || ! multilinkSupported)
							continue;
					}
					
					printf("%s %s output:\n", connection.second.c_str(), links->second.c_str());
					print_output_modes_for_setup(deckLinkOutput, connection.first, links->first);
					if (multilinkSupported)
						print_output_modes_for_setup(deckLinkOutput, connection.first, (BMDSupportedVideoModeFlags)(links->first | bmdSupportedVideoModeDualStream3D));
					printf("\n");
				}
				
				if (keyingSupported)
				{
					printf("%s fill and key outputs:\n", connection.second.c_str());
					print_output_modes_for_setup(deckLinkOutput, connection.first, bmdSupportedVideoModeKeying);
					printf("\n");
				}
				
			}
			else
			{
				
				printf("%s output:\n", connection.second.c_str());
				print_output_modes_for_setup(deckLinkOutput, connection.first, bmdSupportedVideoModeDefault);
				print_output_modes_for_setup(deckLinkOutput, connection.first, bmdSupportedVideoModeDualStream3D);
				printf("\n");
				
			}
		 }
	}
	
bail:
	if (deckLinkAttributes)
		deckLinkAttributes->Release();

	if (deckLinkOutput)
		deckLinkOutput->Release();

	printf("\n");
}

void print_input_mode(IDeckLinkInput* deckLinkInput, BMDVideoConnection connection, BMDSupportedVideoModeFlags flags, IDeckLinkDisplayMode* displayMode, const char* nameSuffix)
{
	std::string				modeName;
	int						modeWidth;
	int						modeHeight;
	BMDTimeValue			frameRateDuration;
	BMDTimeScale			frameRateScale;
	bool					printedMode = false;
	int						unsupportedCount = 0;
	
	// Print the supported pixel formats for this display mode
	for (auto pixelFromat: gPixelFormats)
	{
		dlbool_t supported;

		if (deckLinkInput->DoesSupportVideoMode(connection, displayMode->GetDisplayMode(), pixelFromat.first, flags, &supported) == S_OK && supported)
		{
			if (! printedMode)
			{
				// Mode properties
				mode_name(displayMode, modeName);
				modeWidth = displayMode->GetWidth();
				modeHeight = displayMode->GetHeight();
				displayMode->GetFrameRate(&frameRateDuration, &frameRateScale);
				
				printf(" %-20s %-12s \t %4d x %4d \t %7g FPS\t", modeName.c_str(), nameSuffix, modeWidth, modeHeight, (double)frameRateScale / (double)frameRateDuration);
				
				// Show pixel formats already found to be unsupported
				while (unsupportedCount--)
				{
					printf("%-15s", "------");
				}
				
				printedMode = true;
			}
			
			printf("%-15s", pixelFromat.second.c_str());
		}
		else
		{
			if (printedMode)
				printf("%-15s", "------");
			else
				unsupportedCount++;
		}
	}
	
	if (printedMode)
		printf("\n");
}

void	print_input_modes_for_setup (IDeckLinkInput* deckLinkInput, BMDVideoConnection connection, BMDSupportedVideoModeFlags flags, const char* nameSuffix)
{
	IDeckLinkDisplayModeIterator*   displayModeIterator = NULL;
	IDeckLinkDisplayMode*           displayMode = NULL;
	HRESULT							result;
	
	// Obtain an IDeckLinkDisplayModeIterator to enumerate the display modes supported on input
	result = deckLinkInput->GetDisplayModeIterator(&displayModeIterator);
	if (result != S_OK)
	{
		fprintf(stderr, "Could not obtain the video input display mode iterator - result = %08x\n", result);
		return;
	}
	
	while (displayModeIterator->Next(&displayMode) == S_OK)
	{
		print_input_mode(deckLinkInput, connection, flags, displayMode, nameSuffix);
		displayMode->Release();
	}
	
	displayModeIterator->Release();
}

void	print_input_modes (IDeckLink* deckLink)
{
	IDeckLinkInput*					deckLinkInput = NULL;
	IDeckLinkProfileAttributes*		deckLinkAttributes = NULL;
	HRESULT							result;
	int64_t							ports;

	// Query the DeckLink for its input interface
	result = deckLink->QueryInterface(IID_IDeckLinkInput, (void**)&deckLinkInput);
	if (result != S_OK)
	{
		fprintf(stderr, "Could not obtain the IDeckLinkInput interface - result = %08x\n", result);
		goto bail;
	}
	
	result = deckLink->QueryInterface(IID_IDeckLinkProfileAttributes, (void**)&deckLinkAttributes);
	if (result != S_OK)
	{
		fprintf(stderr, "Could not obtain the IDeckLinkAttributes interface - result = %08x\n", result);
		goto bail;
	}

	result = deckLinkAttributes->GetInt(BMDDeckLinkVideoInputConnections, &ports);

	if (result != S_OK)
		goto bail;


	printf("Supported video input display modes:\n\n");
	for (auto connection: gConnections)
	{
		if (ports & connection.first)
		{
			printf("%s input:\n", connection.second.c_str());

			print_input_modes_for_setup(deckLinkInput, connection.first, bmdSupportedVideoModeDefault, "");
			print_input_modes_for_setup(deckLinkInput, connection.first, bmdSupportedVideoModeDualStream3D, "3D");
			
			printf("\n");
		}
	}
		
bail:
	if (deckLinkAttributes)
		deckLinkAttributes->Release();

	if (deckLinkInput)
		deckLinkInput->Release();

	printf("\n");
}

